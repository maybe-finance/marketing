// fuse.js@7.0.0 downloaded from https://ga.jspm.io/npm:fuse.js@7.0.0/dist/fuse.mjs

function isArray(e){return Array.isArray?Array.isArray(e):"[object Array]"===getTag(e)}const e=1/0;function baseToString(t){if("string"==typeof t)return t;let s=t+"";return"0"==s&&1/t==-e?"-0":s}function toString(e){return null==e?"":baseToString(e)}function isString(e){return"string"===typeof e}function isNumber(e){return"number"===typeof e}function isBoolean(e){return true===e||false===e||isObjectLike(e)&&"[object Boolean]"==getTag(e)}function isObject(e){return"object"===typeof e}function isObjectLike(e){return isObject(e)&&null!==e}function isDefined(e){return void 0!==e&&null!==e}function isBlank(e){return!e.trim().length}function getTag(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const t="Extended search is not available";const s="Incorrect 'index' type";const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY=e=>`Invalid value for key ${e}`;const PATTERN_LENGTH_TOO_LARGE=e=>`Pattern length exceeds max of ${e}.`;const MISSING_KEY_PROPERTY=e=>`Missing ${e} property in key`;const INVALID_KEY_WEIGHT_VALUE=e=>`Property 'weight' in key '${e}' must be a positive integer`;const n=Object.prototype.hasOwnProperty;class KeyStore{constructor(e){this._keys=[];this._keyMap={};let t=0;e.forEach((e=>{let s=createKey(e);this._keys.push(s);this._keyMap[s.id]=s;t+=s.weight}));this._keys.forEach((e=>{e.weight/=t}))}get(e){return this._keyMap[e]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function createKey(e){let t=null;let s=null;let r=null;let i=1;let c=null;if(isString(e)||isArray(e)){r=e;t=createKeyPath(e);s=createKeyId(e)}else{if(!n.call(e,"name"))throw new Error(MISSING_KEY_PROPERTY("name"));const o=e.name;r=o;if(n.call(e,"weight")){i=e.weight;if(i<=0)throw new Error(INVALID_KEY_WEIGHT_VALUE(o))}t=createKeyPath(o);s=createKeyId(o);c=e.getFn}return{path:t,id:s,weight:i,src:r,getFn:c}}function createKeyPath(e){return isArray(e)?e:e.split(".")}function createKeyId(e){return isArray(e)?e.join("."):e}function get(e,t){let s=[];let n=false;const deepGet=(e,t,r)=>{if(isDefined(e))if(t[r]){let i=t[r];const c=e[i];if(!isDefined(c))return;if(r===t.length-1&&(isString(c)||isNumber(c)||isBoolean(c)))s.push(toString(c));else if(isArray(c)){n=true;for(let e=0,s=c.length;e<s;e+=1)deepGet(c[e],t,r+1)}else t.length&&deepGet(c,t,r+1)}else s.push(e)};deepGet(e,isString(t)?t.split("."):t,0);return n?s:s[0]}const r={includeMatches:false,findAllMatches:false,minMatchCharLength:1};const i={isCaseSensitive:false,includeScore:false,keys:[],shouldSort:true,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1};const c={location:0,threshold:.6,distance:100};const o={useExtendedSearch:false,getFn:get,ignoreLocation:false,ignoreFieldNorm:false,fieldNormWeight:1};var a={...i,...r,...c,...o};const h=/[^ ]+/g;function norm(e=1,t=3){const s=new Map;const n=Math.pow(10,t);return{get(t){const r=t.match(h).length;if(s.has(r))return s.get(r);const i=1/Math.pow(r,.5*e);const c=parseFloat(Math.round(i*n)/n);s.set(r,c);return c},clear(){s.clear()}}}class FuseIndex{constructor({getFn:e=a.getFn,fieldNormWeight:t=a.fieldNormWeight}={}){this.norm=norm(t,3);this.getFn=e;this.isCreated=false;this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e;this._keysMap={};e.forEach(((e,t)=>{this._keysMap[e.id]=t}))}create(){if(!this.isCreated&&this.docs.length){this.isCreated=true;isString(this.docs[0])?this.docs.forEach(((e,t)=>{this._addString(e,t)})):this.docs.forEach(((e,t)=>{this._addObject(e,t)}));this.norm.clear()}}add(e){const t=this.size();isString(e)?this._addString(e,t):this._addObject(e,t)}removeAt(e){this.records.splice(e,1);for(let t=e,s=this.size();t<s;t+=1)this.records[t].i-=1}getValueForItemAtKeyId(e,t){return e[this._keysMap[t]]}size(){return this.records.length}_addString(e,t){if(!isDefined(e)||isBlank(e))return;let s={v:e,i:t,n:this.norm.get(e)};this.records.push(s)}_addObject(e,t){let s={i:t,$:{}};this.keys.forEach(((t,n)=>{let r=t.getFn?t.getFn(e):this.getFn(e,t.path);if(isDefined(r))if(isArray(r)){let e=[];const t=[{nestedArrIndex:-1,value:r}];while(t.length){const{nestedArrIndex:s,value:n}=t.pop();if(isDefined(n))if(isString(n)&&!isBlank(n)){let t={v:n,i:s,n:this.norm.get(n)};e.push(t)}else isArray(n)&&n.forEach(((e,s)=>{t.push({nestedArrIndex:s,value:e})}))}s.$[n]=e}else if(isString(r)&&!isBlank(r)){let e={v:r,n:this.norm.get(r)};s.$[n]=e}}));this.records.push(s)}toJSON(){return{keys:this.keys,records:this.records}}}function createIndex(e,t,{getFn:s=a.getFn,fieldNormWeight:n=a.fieldNormWeight}={}){const r=new FuseIndex({getFn:s,fieldNormWeight:n});r.setKeys(e.map(createKey));r.setSources(t);r.create();return r}function parseIndex(e,{getFn:t=a.getFn,fieldNormWeight:s=a.fieldNormWeight}={}){const{keys:n,records:r}=e;const i=new FuseIndex({getFn:t,fieldNormWeight:s});i.setKeys(n);i.setIndexRecords(r);return i}function computeScore$1(e,{errors:t=0,currentLocation:s=0,expectedLocation:n=0,distance:r=a.distance,ignoreLocation:i=a.ignoreLocation}={}){const c=t/e.length;if(i)return c;const o=Math.abs(n-s);return r?c+o/r:o?1:c}function convertMaskToIndices(e=[],t=a.minMatchCharLength){let s=[];let n=-1;let r=-1;let i=0;for(let c=e.length;i<c;i+=1){let c=e[i];if(c&&-1===n)n=i;else if(!c&&-1!==n){r=i-1;r-n+1>=t&&s.push([n,r]);n=-1}}e[i-1]&&i-n>=t&&s.push([n,i-1]);return s}const l=32;function search(e,t,s,{location:n=a.location,distance:r=a.distance,threshold:i=a.threshold,findAllMatches:c=a.findAllMatches,minMatchCharLength:o=a.minMatchCharLength,includeMatches:h=a.includeMatches,ignoreLocation:u=a.ignoreLocation}={}){if(t.length>l)throw new Error(PATTERN_LENGTH_TOO_LARGE(l));const d=t.length;const g=e.length;const f=Math.max(0,Math.min(n,g));let p=i;let M=f;const m=o>1||h;const x=m?Array(g):[];let y;while((y=e.indexOf(t,M))>-1){let e=computeScore$1(t,{currentLocation:y,expectedLocation:f,distance:r,ignoreLocation:u});p=Math.min(e,p);M=y+d;if(m){let e=0;while(e<d){x[y+e]=1;e+=1}}}M=-1;let S=[];let I=1;let L=d+g;const k=1<<d-1;for(let n=0;n<d;n+=1){let i=0;let o=L;while(i<o){const e=computeScore$1(t,{errors:n,currentLocation:f+o,expectedLocation:f,distance:r,ignoreLocation:u});e<=p?i=o:L=o;o=Math.floor((L-i)/2+i)}L=o;let a=Math.max(1,f-o+1);let h=c?g:Math.min(f+o,g)+d;let l=Array(h+2);l[h+1]=(1<<n)-1;for(let i=h;i>=a;i-=1){let c=i-1;let o=s[e.charAt(c)];m&&(x[c]=+!!o);l[i]=(l[i+1]<<1|1)&o;n&&(l[i]|=(S[i+1]|S[i])<<1|1|S[i+1]);if(l[i]&k){I=computeScore$1(t,{errors:n,currentLocation:c,expectedLocation:f,distance:r,ignoreLocation:u});if(I<=p){p=I;M=c;if(M<=f)break;a=Math.max(1,2*f-M)}}}const y=computeScore$1(t,{errors:n+1,currentLocation:f,expectedLocation:f,distance:r,ignoreLocation:u});if(y>p)break;S=l}const v={isMatch:M>=0,score:Math.max(.001,I)};if(m){const e=convertMaskToIndices(x,o);e.length?h&&(v.indices=e):v.isMatch=false}return v}function createPatternAlphabet(e){let t={};for(let s=0,n=e.length;s<n;s+=1){const r=e.charAt(s);t[r]=(t[r]||0)|1<<n-s-1}return t}class BitapSearch{constructor(e,{location:t=a.location,threshold:s=a.threshold,distance:n=a.distance,includeMatches:r=a.includeMatches,findAllMatches:i=a.findAllMatches,minMatchCharLength:c=a.minMatchCharLength,isCaseSensitive:o=a.isCaseSensitive,ignoreLocation:h=a.ignoreLocation}={}){this.options={location:t,threshold:s,distance:n,includeMatches:r,findAllMatches:i,minMatchCharLength:c,isCaseSensitive:o,ignoreLocation:h};this.pattern=o?e:e.toLowerCase();this.chunks=[];if(!this.pattern.length)return;const addChunk=(e,t)=>{this.chunks.push({pattern:e,alphabet:createPatternAlphabet(e),startIndex:t})};const u=this.pattern.length;if(u>l){let e=0;const t=u%l;const s=u-t;while(e<s){addChunk(this.pattern.substr(e,l),e);e+=l}if(t){const e=u-l;addChunk(this.pattern.substr(e),e)}}else addChunk(this.pattern,0)}searchIn(e){const{isCaseSensitive:t,includeMatches:s}=this.options;t||(e=e.toLowerCase());if(this.pattern===e){let t={isMatch:true,score:0};s&&(t.indices=[[0,e.length-1]]);return t}const{location:n,distance:r,threshold:i,findAllMatches:c,minMatchCharLength:o,ignoreLocation:a}=this.options;let h=[];let l=0;let u=false;this.chunks.forEach((({pattern:t,alphabet:d,startIndex:g})=>{const{isMatch:f,score:p,indices:M}=search(e,t,d,{location:n+g,distance:r,threshold:i,findAllMatches:c,minMatchCharLength:o,includeMatches:s,ignoreLocation:a});f&&(u=true);l+=p;f&&M&&(h=[...h,...M])}));let d={isMatch:u,score:u?l/this.chunks.length:1};u&&s&&(d.indices=h);return d}}class BaseMatch{constructor(e){this.pattern=e}static isMultiMatch(e){return getMatch(e,this.multiRegex)}static isSingleMatch(e){return getMatch(e,this.singleRegex)}search(){}}function getMatch(e,t){const s=e.match(t);return s?s[1]:null}class ExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(e){const t=e===this.pattern;return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}}class InverseExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(e){const t=e.indexOf(this.pattern);const s=-1===t;return{isMatch:s,score:s?0:1,indices:[0,e.length-1]}}}class PrefixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(e){const t=e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}}class InversePrefixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(e){const t=!e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}}class SuffixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(e){const t=e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[e.length-this.pattern.length,e.length-1]}}}class InverseSuffixExactMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(e){const t=!e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}}class FuzzyMatch extends BaseMatch{constructor(e,{location:t=a.location,threshold:s=a.threshold,distance:n=a.distance,includeMatches:r=a.includeMatches,findAllMatches:i=a.findAllMatches,minMatchCharLength:c=a.minMatchCharLength,isCaseSensitive:o=a.isCaseSensitive,ignoreLocation:h=a.ignoreLocation}={}){super(e);this._bitapSearch=new BitapSearch(e,{location:t,threshold:s,distance:n,includeMatches:r,findAllMatches:i,minMatchCharLength:c,isCaseSensitive:o,ignoreLocation:h})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(e){return this._bitapSearch.searchIn(e)}}class IncludeMatch extends BaseMatch{constructor(e){super(e)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(e){let t=0;let s;const n=[];const r=this.pattern.length;while((s=e.indexOf(this.pattern,t))>-1){t=s+r;n.push([s,t-1])}const i=!!n.length;return{isMatch:i,score:i?0:1,indices:n}}}const u=[ExactMatch,IncludeMatch,PrefixExactMatch,InversePrefixExactMatch,InverseSuffixExactMatch,SuffixExactMatch,InverseExactMatch,FuzzyMatch];const d=u.length;const g=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;const f="|";function parseQuery(e,t={}){return e.split(f).map((e=>{let s=e.trim().split(g).filter((e=>e&&!!e.trim()));let n=[];for(let e=0,r=s.length;e<r;e+=1){const r=s[e];let i=false;let c=-1;while(!i&&++c<d){const e=u[c];let s=e.isMultiMatch(r);if(s){n.push(new e(s,t));i=true}}if(!i){c=-1;while(++c<d){const e=u[c];let s=e.isSingleMatch(r);if(s){n.push(new e(s,t));break}}}}return n}))}const p=new Set([FuzzyMatch.type,IncludeMatch.type]);class ExtendedSearch{constructor(e,{isCaseSensitive:t=a.isCaseSensitive,includeMatches:s=a.includeMatches,minMatchCharLength:n=a.minMatchCharLength,ignoreLocation:r=a.ignoreLocation,findAllMatches:i=a.findAllMatches,location:c=a.location,threshold:o=a.threshold,distance:h=a.distance}={}){this.query=null;this.options={isCaseSensitive:t,includeMatches:s,minMatchCharLength:n,findAllMatches:i,ignoreLocation:r,location:c,threshold:o,distance:h};this.pattern=t?e:e.toLowerCase();this.query=parseQuery(this.pattern,this.options)}static condition(e,t){return t.useExtendedSearch}searchIn(e){const t=this.query;if(!t)return{isMatch:false,score:1};const{includeMatches:s,isCaseSensitive:n}=this.options;e=n?e:e.toLowerCase();let r=0;let i=[];let c=0;for(let n=0,o=t.length;n<o;n+=1){const o=t[n];i.length=0;r=0;for(let t=0,n=o.length;t<n;t+=1){const n=o[t];const{isMatch:a,indices:h,score:l}=n.search(e);if(!a){c=0;r=0;i.length=0;break}r+=1;c+=l;if(s){const e=n.constructor.type;p.has(e)?i=[...i,...h]:i.push(h)}}if(r){let e={isMatch:true,score:c/r};s&&(e.indices=i);return e}}return{isMatch:false,score:1}}}const M=[];function register(...e){M.push(...e)}function createSearcher(e,t){for(let s=0,n=M.length;s<n;s+=1){let n=M[s];if(n.condition(e,t))return new n(e,t)}return new BitapSearch(e,t)}const m={AND:"$and",OR:"$or"};const x={PATH:"$path",PATTERN:"$val"};const isExpression=e=>!!(e[m.AND]||e[m.OR]);const isPath=e=>!!e[x.PATH];const isLeaf=e=>!isArray(e)&&isObject(e)&&!isExpression(e);const convertToExplicit=e=>({[m.AND]:Object.keys(e).map((t=>({[t]:e[t]})))});function parse(e,t,{auto:s=true}={}){const next=e=>{let n=Object.keys(e);const r=isPath(e);if(!r&&n.length>1&&!isExpression(e))return next(convertToExplicit(e));if(isLeaf(e)){const i=r?e[x.PATH]:n[0];const c=r?e[x.PATTERN]:e[i];if(!isString(c))throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(i));const o={keyId:createKeyId(i),pattern:c};s&&(o.searcher=createSearcher(c,t));return o}let i={children:[],operator:n[0]};n.forEach((t=>{const s=e[t];isArray(s)&&s.forEach((e=>{i.children.push(next(e))}))}));return i};isExpression(e)||(e=convertToExplicit(e));return next(e)}function computeScore(e,{ignoreFieldNorm:t=a.ignoreFieldNorm}){e.forEach((e=>{let s=1;e.matches.forEach((({key:e,norm:n,score:r})=>{const i=e?e.weight:null;s*=Math.pow(0===r&&i?Number.EPSILON:r,(i||1)*(t?1:n))}));e.score=s}))}function transformMatches(e,t){const s=e.matches;t.matches=[];isDefined(s)&&s.forEach((e=>{if(!isDefined(e.indices)||!e.indices.length)return;const{indices:s,value:n}=e;let r={indices:s,value:n};e.key&&(r.key=e.key.src);e.idx>-1&&(r.refIndex=e.idx);t.matches.push(r)}))}function transformScore(e,t){t.score=e.score}function format(e,t,{includeMatches:s=a.includeMatches,includeScore:n=a.includeScore}={}){const r=[];s&&r.push(transformMatches);n&&r.push(transformScore);return e.map((e=>{const{idx:s}=e;const n={item:t[s],refIndex:s};r.length&&r.forEach((t=>{t(e,n)}));return n}))}class Fuse{constructor(e,s={},n){this.options={...a,...s};if(this.options.useExtendedSearch&&false)throw new Error(t);this._keyStore=new KeyStore(this.options.keys);this.setCollection(e,n)}setCollection(e,t){this._docs=e;if(t&&!(t instanceof FuseIndex))throw new Error(s);this._myIndex=t||createIndex(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(e){if(isDefined(e)){this._docs.push(e);this._myIndex.add(e)}}remove(e=(()=>false)){const t=[];for(let s=0,n=this._docs.length;s<n;s+=1){const r=this._docs[s];if(e(r,s)){this.removeAt(s);s-=1;n-=1;t.push(r)}}return t}removeAt(e){this._docs.splice(e,1);this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:t=-1}={}){const{includeMatches:s,includeScore:n,shouldSort:r,sortFn:i,ignoreFieldNorm:c}=this.options;let o=isString(e)?isString(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);computeScore(o,{ignoreFieldNorm:c});r&&o.sort(i);isNumber(t)&&t>-1&&(o=o.slice(0,t));return format(o,this._docs,{includeMatches:s,includeScore:n})}_searchStringList(e){const t=createSearcher(e,this.options);const{records:s}=this._myIndex;const n=[];s.forEach((({v:e,i:s,n:r})=>{if(!isDefined(e))return;const{isMatch:i,score:c,indices:o}=t.searchIn(e);i&&n.push({item:e,idx:s,matches:[{score:c,value:e,norm:r,indices:o}]})}));return n}_searchLogical(e){const t=parse(e,this.options);const evaluate=(e,t,s)=>{if(!e.children){const{keyId:n,searcher:r}=e;const i=this._findMatches({key:this._keyStore.get(n),value:this._myIndex.getValueForItemAtKeyId(t,n),searcher:r});return i&&i.length?[{idx:s,item:t,matches:i}]:[]}const n=[];for(let r=0,i=e.children.length;r<i;r+=1){const i=e.children[r];const c=evaluate(i,t,s);if(c.length)n.push(...c);else if(e.operator===m.AND)return[]}return n};const s=this._myIndex.records;const n={};const r=[];s.forEach((({$:e,i:s})=>{if(isDefined(e)){let i=evaluate(t,e,s);if(i.length){if(!n[s]){n[s]={idx:s,item:e,matches:[]};r.push(n[s])}i.forEach((({matches:e})=>{n[s].matches.push(...e)}))}}}));return r}_searchObjectList(e){const t=createSearcher(e,this.options);const{keys:s,records:n}=this._myIndex;const r=[];n.forEach((({$:e,i:n})=>{if(!isDefined(e))return;let i=[];s.forEach(((s,n)=>{i.push(...this._findMatches({key:s,value:e[n],searcher:t}))}));i.length&&r.push({idx:n,item:e,matches:i})}));return r}_findMatches({key:e,value:t,searcher:s}){if(!isDefined(t))return[];let n=[];if(isArray(t))t.forEach((({v:t,i:r,n:i})=>{if(!isDefined(t))return;const{isMatch:c,score:o,indices:a}=s.searchIn(t);c&&n.push({score:o,key:e,value:t,idx:r,norm:i,indices:a})}));else{const{v:r,n:i}=t;const{isMatch:c,score:o,indices:a}=s.searchIn(r);c&&n.push({score:o,key:e,value:r,norm:i,indices:a})}return n}}Fuse.version="7.0.0";Fuse.createIndex=createIndex;Fuse.parseIndex=parseIndex;Fuse.config=a;Fuse.parseQuery=parse;register(ExtendedSearch);export{Fuse as default};

